#!/usr/local/bin/sbcl --script
;; -*- Mode: Lisp -*-

(format *terminal-io* "Loading...")
(force-output *terminal-io*)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (let ((*standard-output* (make-broadcast-stream)))
    (require 'asdf)
    (require 'gotanda)
    (load "color")))

(in-package :got)

(defun make-keyword (symb)
  (values (intern (string-upcase symb) :KEYWORD)))

(setf (symbol-function 'dispatch)
      (alet (list-items)
            (macrolet ((rec (&rest args) `(if (listp ,(car (last args)))
                                              (apply this ,@args)
                                              (funcall this ,@args)))
                       (get-item (idx)
                         `(nth (- (parse-integer ,idx) 1) list-items)))
              (dlambda
               (:create (&optional body deadline)
                        (let ((task (create-task
                                     :body (or body (prompt-read "Body?>"))
                                     :deadline (or deadline (prompt-read "Deadline?>")))))
                          (format t "New Task: ~a~%" (get-body task))))
               (:list (&optional tag deadline)
                      (setf list-items
                            (list-task :tag tag
                                       :deadline (and deadline
                                                      (destructuring-bind (compare-fn datestr)
                                                          (cl-ppcre:split #\Space deadline)
                                                        (list (intern compare-fn) (str->date datestr))))))
                      (format t "~{~{~a: ~a ~:[~;~:*[~a]~]~}~%~}"
                              (loop for task in list-items
                                 for i = 1 then (1+ i)
                                 collect `(,(color:style (:gray) i)
                                            ,(color:style (:cyan) (get-body task))
                                            ,(aand (get-deadline task)
                                                   (color:style (:gray) it))))))
               (:edit (index &optional body deadline)
                      (let ((task (get-item index)))
                        (case task
                          ((NIL) (rec :error "Out of range."))
                          ((DELETED) (rec :error "It is already deleted."))
                          (t (edit-task task
                                        :body (or body (prompt-read "Body?>"))
                                        :deadline (or deadline (prompt-read "Deadline?>")))))))
               (:delete (index)
                        (let ((task (get-item index)))
                          (case task
                            ((NIL) (rec :error "Out of range."))
                            ((DELETED) (rec :error "It is already deleted."))
                            (t (clsql:delete-instance-records task)
                               (setf (get-item index) 'DELETED)))))
               (:action-for (n)
                            (destructuring-bind (action &rest args)
                                (or (split-params (prompt-read "What action?>"))
                                    (rec :action-for n))
                              (let ((action-kwd (make-keyword action)))
                                (if (member action-kwd '(:edit :delete))
                                    (rec action-kwd n args)
                                    (rec :error "Invalid action")))))
               (:error (form &rest args) (format t (concatenate 'string form "~%") args))
               (t (&rest args) (format t "Undefined action: ~a~%" (car args)))))))

(defun run-dispatch (args)
  (if (#~m/^\d+$/ (car args)) (push :action-for args))
  (apply #'dispatch (make-keyword (car args)) (cdr args)))

(format *terminal-io* "Done.~%")

(loop for input = (prompt-read ">")
     with clsql:*default-caching* = nil
     until (zerop (length input))
     do (run-dispatch (split-params input)))
