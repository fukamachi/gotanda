#!/usr/local/bin/sbcl --script
;; -*- Mode: Lisp -*-

(format *terminal-io* "Loading...")
(force-output *terminal-io*)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (let ((*standard-output* (make-broadcast-stream)))
    (require 'asdf)
    (require 'gotanda)
    (load "color")))

(in-package :got)

(defvar *list-items* nil)

(defun make-keyword (symb)
  (values (intern (string-upcase symb) :KEYWORD)))

(setf (symbol-function 'dispatch)
      (alet ((actions (make-hash-table)))
            (dlambda
             (:define (name def)
                 (setf (gethash name actions) def))
             (:do (name &rest args)
                  (aif (gethash name actions)
                       (apply it args)
                       (funcall this :error "Undefined action: ~a~%" name))))))

(defmacro define-action (name args &body body)
  `(dispatch :define (make-keyword ',name) (lambda ,args ,@body)))

(define-action list (&optional tag deadline)
  (setf *list-items*
        (list-task :tag tag
                   :deadline (and deadline
                                  (destructuring-bind (compare-fn datestr)
                                      (cl-ppcre:split #\Space deadline)
                                    (list (intern compare-fn) (str->date datestr))))))
  (format t "~{~{~a: ~a ~@[[~a]~]~}~%~}"
          (loop for task in *list-items*
             for i = 1 then (1+ i)
             collect `(,(color:style (:gray) i)
                        ,(color:style (:cyan) (get-body task))
                        ,(aand (get-deadline task)
                               (color:style (:gray) it))))))

(define-action create (&optional body deadline)
  (let ((task (create-task
               :body (or body (prompt-read "Body?>"))
               :deadline (or deadline (prompt-read "Deadline?>")))))
    (format t "New Task: ~a~%" (get-body task))))

(define-action edit (index-string &optional body deadline)
  (let* ((idx (- (parse-integer index-string) 1))
         (task (nth idx *list-items*)))
    (case task
      ((NIL) (dispatch :do :error "Out of range."))
      ((DELETED) (dispatch :do :error "It is already deleted."))
      (t (edit-task task
                    :body (or body (prompt-read "Body?>"))
                    :deadline (or deadline (prompt-read "Deadline?>")))))))

(define-action delete (index-string)
  (let* ((idx (- (parse-integer index-string) 1))
         (task (nth idx *list-items*)))
    (case task
      ((NIL) (dispatch :do :error "Out of range."))
      ((DELETED) (dispatch :do :error "It is already deleted."))
      (t (clsql:delete-instance-records task)
         (setf (nth idx *list-items*) 'DELETED)))))

(define-action action-for (n)
  (destructuring-bind (action &rest args)
      (or (split-params (prompt-read "What action?>"))
          (dispatch :do :action-for n))
    (let ((action-kwd (make-keyword action)))
      (if (member action-kwd '(:edit :delete))
          (dispatch :do action-kwd n args)
          (dispatch :do :error "Invalid action")))))

(define-action error (form &rest args)
  (format t (format nil "~a~%" form) args))

(defun run-dispatch (args)
  (if (#~m/^\d+$/ (car args)) (push :action-for args))
  (apply #'dispatch :do (make-keyword (car args)) (cdr args)))

(format *terminal-io* "Done.~%")

(loop for input = (prompt-read ">")
     with clsql:*default-caching* = nil
     until (eq nil input)
     unless (string= "" input)
     do (run-dispatch (split-params input)))
